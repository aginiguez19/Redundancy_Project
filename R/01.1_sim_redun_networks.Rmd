---
title: "Forms of Redundant Networks"
author: "Abraham IÃ±iguez"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Network Test & Setup:

### Load Packages

```{r message = FALSE}
library(qgraph)
library(igraph)
source("00_project_functions.R")
```

### Form 1: HCSF


```{r}
nsim <- 10
nv <- 4
ep <- .9
EF <- .5

```

```{r echo = FALSE}
# Functions needed
# corr_gen() ~ Obtain true network corr matrix
# cor2pcor() ~ Move from corr matrix to pcor matrix
# hcsf() ~ Obtain redundant corr matrix that is highly correlated & same function ~ to be changed

# Set empty matrix and array to hold results
node_names <- c(paste0("P", 1:(nv-1), ".r.diff"))
net_change_matrix <- matrix(data = NA, nrow = nsim, ncol = nv, dimnames = list(NULL, c(node_names, "Target.r.diff")))

closeness_matrix <- matrix(data = NA, nrow = nsim, ncol = nv, dimnames = list(NULL, c(node_names, "Target.r.diff")))

betweenness_matrix <- matrix(data = NA, nrow = nsim, ncol = nv, dimnames = list(NULL, c(node_names, "Target.r.diff")))


metrics_hcsf <- array(NA, dim = c(nsim, (2*nv + 1), 3),
                 dimnames = list(NULL, c(paste0("P", 1:(nv-1)), "Target", paste0("P", 1:(nv-1), ".r"), "Target.r", "Clone"), c("strength", "closeness", "betweenness")))



for (i in 1:nsim){
  true_mat <- corr_gen(nv = nv, EF = EF, edge.probability = ep)
  redun_mat <- hcsf(matrix = true_mat) # This is probably where I need to change the code, I am not sure what to do. If I do not make any progress today, I will ask in the node redundancy chat 
  redun_subset <- redun_mat[1:nv, 1:nv]
  redun_pcor_subset <- cor2pcor(redun_subset)
  redun_pcor <- cor2pcor(redun_mat)
# Create one block matrix for easy computation
  one <- cbind(redun_pcor_subset, diag(0, nv, nv+1))
  two <- cbind(diag(0, nv+1, nv), redun_pcor)
  the_g <- rbind(one, two)
  colnames(the_g) <- c(paste0("P", 1:(nv-1)), "Target", paste0("P", 1:(nv-1), ".r"), "Target.r", "Clone")
  
# qgraph plots and graph matrices
  g1 = qgraph(redun_pcor_subset, edge.labels = TRUE, DoNotPlot = TRUE)
  if (i == 1){
  g2 = qgraph(redun_pcor, edge.labels = TRUE, DoNotPlot = TRUE)
  pp = averageLayout(g2)}
  png(filename = paste0('/Users/abraham/Library/CloudStorage/Box/Redundancy_Project/R/Network Graphs/HCSF_Graph_', i, ".png"), width = 1000, height = 500)
  par(mfrow = c(1, 2))
  g1 = qgraph(redun_pcor_subset, layout = pp[1:nv,], edge.labels = TRUE, theme = "colorblind", labels = colnames(the_g)[1:nv], maximum = 1, vsize = 11, DoNotPlot = TRUE)
  g1 = makeBW(g1)
  g2 = qgraph(redun_pcor,layout = pp, edge.labels = TRUE, theme = "colorblind", labels = colnames(the_g)[(nv+1):(2*nv + 1)], maximum = 1, vsize = 11, DoNotPlot = TRUE)
  g2 = makeBW(g2)
  graphics.off()
  
  the_g <- graph_from_adjacency_matrix(the_g, mode = "undirected", weighted = TRUE)
  saveRDS(the_g, paste0('/Users/abraham/Library/CloudStorage/Box/Redundancy_Project/R/Graph Matrices/HCSF_File_', i, ".RDS"))
  
#Compute Strength, Closeness, and Betweenness    
  metrics_hcsf[i,, "strength"] <- strength(the_g)
  metrics_hcsf[i,,"closeness"] <- closeness(the_g, weights = 1/round(abs(E(the_g)$weight),2), normalized = TRUE)
  metrics_hcsf[i,,"betweenness"] <- betweenness(the_g, weights = 1/(abs(E(the_g)$weight)), normalized = FALSE)

  if (!is.null(metrics_hcsf)) {
  saveRDS(metrics_hcsf, paste0('/Users/abraham/Library/CloudStorage/Box/Redundancy_Project/R/Metrics/HCSF_Metrics_', i , ".RDS"))
  prev_file <- paste0('/Users/abraham/Library/CloudStorage/Box/Redundancy_Project/R/Metrics/HCSF_Metrics_', i - 1, ".RDS")
  if (file.exists(prev_file)) {
    file.remove(prev_file)
  }

} else {
  message(paste0("Ope, this run had an error. Preserving simulation as of Replication ", i))
}
  
# Compute clone inclusion difference in redundancy network
  total_strength <- strength(the_g)
  connections_2_clone <- E(the_g)$weight[which(grepl("Clone", as_ids(E(the_g))))]
  net_change_matrix[i,] <- (total_strength[(nv+1):(2*nv)] - connections_2_clone) - total_strength[1:nv]
  
  clone_edges <- E(the_g)[grepl("Clone", as_ids(E(the_g)))]
  g_no_clone <- delete_edges(the_g, clone_edges)
  closeness_woc <- closeness(g_no_clone, normalized = TRUE, weights = 1/abs(E(g_no_clone)$weight))
  closeness_wthc <- closeness(the_g, normalized = TRUE, weights = 1/abs(E(the_g)$weight))
  closeness_matrix[i,] <- closeness_woc[(nv+1):(2*nv)] - closeness_wthc[1:nv]
  
 betweenness_woc <- betweenness(g_no_clone, normalized = FALSE, weights = 1/abs(E(g_no_clone)$weight))
 betweenness_wthc <- betweenness(the_g, normalized = FALSE,  weights = 1/abs(E(the_g)$weight))
 betweenness_matrix[i, ] <- betweenness_woc[(nv+1):(2*nv)] - betweenness_wthc[1:nv]

}
```


### Form 2: HCDF

```{r}

```

### Form 3: WCSF

```{r}
cor.mats = list()
types = paste0("Redun", 1:4)
reps = paste0("Run", 1:100)
for(i in types){
  temp = list()
  for(j in reps){
    temp[[j]] = matrix(rnorm(16), 4, 4)
  }  
  cor.mats[[i]] = temp
}
cor.mats$Redun1$Run26
```



