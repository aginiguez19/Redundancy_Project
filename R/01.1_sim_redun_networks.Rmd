---
title: "Forms of Redundant Networks"
author: "Abraham IÃ±iguez"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Network Test & Setup:

### Load Packages

```{r message = FALSE}
library(qgraph)
library(igraph)
source("00_project_functions.R")
```

#### True Network Test {.unlisted .unnumbered}

```{r include = FALSE}
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true_mat <- corr_gen(nv = 4, EF = 0.5, edge.probability = .8)
# cor2pcor() converts correlation matrix into partial correlation matrix
true_pcor <- cor2pcor(true_mat)
#Graph
   qgraph(true_pcor, edge.labels = TRUE,
                  edge.width = 2.5, layout = "spring",
                  theme = "colorblind")
 title("True Network", line = 2.5)
```

### Form 1: HCSF

```{r}
# Functions needed
# corr_gen() ~ Obtain true network corr matrix
# cor2pcor() ~ Move from corr matrix to pcor matrix
# hcsf() ~ Obtain redundant corr matrix that is highly correlated & same function


metrics <- array(NA, dim = c(1000, 11, 3),
                 dimnames = list(NULL, c("p1_true", "p2_true", "p3_true",
                 "target", "p1_redun", "p2_redun", "p3_redun", "target_redun",
                 "clone","peripheral_change", "target_change"),
                                       c("strength", "closeness",
                                         "betweenness")))

for (i in 1:1000){
  true_mat <- corr_gen(nv = 4, EF = .5, edge.probability = .9)
  redun_mat <- hcsf(matrix = true_mat)
  redun_subset <- redun_mat[1:4, 1:4]
  redun_pcor_subset <- cor2pcor(redun_subset)
  redun_pcor <- cor2pcor(redun_mat)
  
  g_subset <- graph_from_adjacency_matrix(redun_pcor_subset,
                                          mode = "undirected",
                                          weighted = TRUE)
  g_full <- graph_from_adjacency_matrix(redun_pcor,
                                        mode = "undirected",
                                        weighted = TRUE)
 ## Strength ##
  strength_subset <- strength(g_subset)
  metrics[i, 1:4, "strength"] <- strength_subset
  strength_full <- strength(g_full)
  metrics[i, 5:9, "strength"] <- strength_full
  peripheral_change_s <- mean(strength_full[1:3] - strength_subset[1:3])
  target_change_s <- strength_full[4] - strength_subset[4]
  metrics[i, 10:11,"strength"] <- c(peripheral_change_s, target_change_s)

  ## Closeness ##
  closeness_subset <- closeness(g_subset, weights = 1/abs(E(g_subset)$weight))
  metrics[i, 1:4, "closeness"] <- closeness_subset
  closeness_full <- closeness(g_full, weights = 1/abs(E(g_full)$weight))
  metrics[i, 5:9, "closeness"] <- closeness_full
  peripheral_change_c <- mean(closeness_full[1:3] - closeness_subset[1:3])
  target_change_c <- closeness_full[4] - closeness_subset[4]
  metrics[i, 10:11,"closeness"] <- c(peripheral_change_c, target_change_c)
  
  ## Betweenness ## 
  betweenness_subset <- betweenness(g_subset,
                                   weights = 1/abs(E(g_subset)$weight))
  metrics[i, 1:4, "betweenness"] <- betweenness_subset
  betweenness_full <- betweenness(g_full, weights = 1/abs(E(g_full)$weight))
  metrics[i, 5:9, "betweenness"] <- betweenness_full
  peripheral_change_b <- mean(betweenness_full[1:3] - betweenness_subset[1:3])
  target_change_b <- betweenness_full[4] - betweenness_subset[4]
  metrics[i,10:11,"betweenness"] <- c(peripheral_change_b, target_change_b)
}

head(metrics)

```



### Form 2: HCDF

```{r}
# Check weights argument input for betweenness and closeness

```




