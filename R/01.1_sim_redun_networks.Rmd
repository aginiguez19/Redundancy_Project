---
title: "Forms of Redundant Networks"
author: "Abraham Iniguez"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Networks:

### Load Packages

```{r}
library(qgraph)
library(igraph)
source("00_correlation_matrix_function.R")
```

#### True Network:

```{r}
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true_mat <- corr_gen(nv = 9, EF = 0, edge.probability = .8)


# Take inverse of true.mat to obtain precision matrix
true_precision <- solve(true_mat)


# Convert precision matrix into partial correlation matrix
true_pcor <- wi2net(true_precision)

#Turn process into a function
cor2pcor <- function(matrix){
  precision_mat <- solve(matrix)
  pcor_mat <- wi2net(precision_mat)
  return(pcor_mat)
}

#Test
true_pcor <- cor2pcor(true_mat)


qgraph(true_pcor, edge.labels = TRUE,
                  edge.width = 2, layout = "spring",
                  asize = 5, vTrans = 260, theme = "colorblind",
                  title = "True Network")


```

#### Form 1: Highly correlated similar function

```{r}
#Create Lambda Matrix depending on size of true network

#Extract dimensions of true network 
dimensions <- dim(true.mat)

#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements 
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument 
lambda.matrix

#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators 
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)



#Measurement error aka theta
dimensions.theta <- dim(redun.mat)

theta <- diag(.05, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05


#Add error to redun.mat
redun.mat <- redun.mat + theta


qgraph(cor2pcor(redun.mat), edge.labels = TRUE,
                  edge.width = 2, layout = "circle",
                  asize = 5, vTrans = 260, theme = "colorblind",
                  title = "True Network")






#Some interesting things

#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)

#Gives you the last element
tail(c(lambda.matrix), 1)


```
