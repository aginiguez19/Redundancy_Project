true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
corr.gen = function(nv, EF, edge.probability){
flag = 0
while(flag < 1){
diag_mat <- diag(1,nv)
off_diag_elements <- diag_mat[lower.tri(diag_mat)]
n_elements <- length(off_diag_elements)
edge_vector <- ifelse(rbinom(n = n_elements, size = 1,
prob = edge.probability) == 1,
round(rnorm(n_elements, mean = EF, sd = .5), 4), 0)
diag_mat[lower.tri(diag_mat)] <- edge_vector
diag_mat[upper.tri(diag_mat)] <- t(diag_mat)[upper.tri(diag_mat)]
if(min(eigen(diag_mat, only.values = TRUE)$values)>=0){
flag = 1
}
}
return(diag_mat)
}
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Create Lambda Matrix depending on size of true network
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta.last.element <- nrow(theta) * ncol(theta)
theta[theta.last.element] <- .05
#Add error to redun.mat
redun.mat <- redun.mat + theta
pcor(redun.mat)
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Some interesting things
#Wrapping a matrix with c() will flatten it into a vector
c(lambda.matrix)
#Gives you the last element
tail(c(lambda.matrix), 1)
corr.gen = function(nv, EF, edge.probability){
flag = 0
while(flag < 1){
diag_mat <- diag(1,nv)
off_diag_elements <- diag_mat[lower.tri(diag_mat)]
n_elements <- length(off_diag_elements)
edge_vector <- ifelse(rbinom(n = n_elements, size = 1,
prob = edge.probability) == 1,
round(rnorm(n_elements, mean = EF, sd = .5), 4), 0)
diag_mat[lower.tri(diag_mat)] <- edge_vector
diag_mat[upper.tri(diag_mat)] <- t(diag_mat)[upper.tri(diag_mat)]
if(min(eigen(diag_mat, only.values = TRUE)$values)>=0){
flag = 1
}
}
return(diag_mat)
}
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
lambda.matrix
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
library(qgraph)
library(igraph)
library(qgraph)
library(igraph)
# Use corr.gen() function to obtain correlation matrix
# nv = number of variables, EF = effective features of matrix
# edge. probability = probability an edge is present or not
true.mat <- corr.gen(nv = 3, EF = 0, edge.probability = .8)
# Take inverse of true.mat to obtain precision matrix
true.precision <- solve(true.mat)
# Convert precision matrix into partial correlation matrix
true.pcor <- wi2net(true.precision)
#Turn process into a function
cor2pcor <- function(matrix){
precision.mat <- solve(matrix)
pcor.mat <- wi2net(precision.mat)
return(pcor.mat)
}
#Test
true.pcor <- cor2pcor(true.mat)
qgraph(true.pcor, edge.labels = TRUE,
edge.width = 2, layout = "spring",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
#Extract dimensions of true network
dimensions <- dim(true.mat)
#Set up lambda matrix to make possible, matrix multiplication of true network
lambda.matrix <- diag(x = 1, nrow = dimensions[1] + 1 , ncol = dimensions[2])
lambda.matrix
#Code to change last element aka the factor loading on the same LV
last.element <- nrow(lambda.matrix) * ncol(lambda.matrix) #Gives total # of elements
lambda.matrix[last.element] <- .9 #Since we want to change the last element, index by total # elements = last element in vector
#Will be able to change as argument
lambda.matrix
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
#Using lambda * psi * transpose of lambda we get the redudant matrix of the indicators
redun.mat <- lambda.matrix %*% true.mat %*% t(lambda.matrix)
#Measurement error aka theta
dimensions.theta <- dim(redun.mat)
theta <- diag(0, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta
theta <- diag(.05, nrow = dimensions.theta[1], ncol = dimensions.theta[2])
theta
#Add error to redun.mat
redun.mat <- redun.mat + theta
qgraph(pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
qgraph(cor2pcor(redun.mat), edge.labels = TRUE,
edge.width = 2, layout = "circle",
asize = 5, vTrans = 260, theme = "colorblind",
title = "True Network")
sys.source("Correlation Matrix Function.R", envir = knitr::knit_global())
sys.source("Correlation Matrix Functionx.R", envir = knitr::knit_global())
corr.gen = function(nv, EF, edge.probability){
flag = 0
while(flag < 1){
diag_mat <- diag(1,nv)
off_diag_elements <- diag_mat[lower.tri(diag_mat)]
n_elements <- length(off_diag_elements)
edge_vector <- ifelse(rbinom(n = n_elements, size = 1,
prob = edge.probability) == 1,
round(rnorm(n_elements, mean = EF, sd = .05), 4), 0)
diag_mat[lower.tri(diag_mat)] <- edge_vector
diag_mat[upper.tri(diag_mat)] <- t(diag_mat)[upper.tri(diag_mat)]
if(min(eigen(diag_mat, only.values = TRUE)$values)>=0){
flag = 1
}
}
return(diag_mat)
}
sys.source("Correlation Matrix Functionx.R", envir = knitr::knit_global())
sys.source("Correlation Matrix Functionx.R", envir = knitr::knit_global())
#Original
n_elements <- 3
sys.source("Correlation Matrix Functionx.R", envir = knitr::knit_global())
#Original
diag_mat <- diag(1, 3,3)
sys.source("Correlation Matrix Functionx.R", envir = knitr::knit_global())
sys.source("Correlation Matrix Functionx.R")
sys.source("Correlation Matrix Functionx.R")
sys.source("Correlation Matrix Functionx.R")
source("Correlation Matrix Functionx.R")
library(qgraph)
library(igraph)
source("Correlation Matrix Function.R")
library(qgraph)
library(igraph)
source("Correlation Matrix Function.R")
library(qgraph)
library(igraph)
source("Correlation Matrix Function.R")
library(qgraph)
library(igraph)
source("Correlation Matrix Function.R")
View(corr.gen)
library(qgraph)
library(igraph)
source("Correlation Matrix Function.R")
# Helpful Tips ------------------------------------------------------------
rbinom(n = 3, size = 1, prob = .5)
getwd()
getwd()
list.files()
list.files("Desktop")
list.files("desktop")
list.files(/Users/abraham/Desktop)
list.files(Users/abraham/Desktop)
list.files("02_metrics.R")
list.files("/Users/abraham/Desktop")
